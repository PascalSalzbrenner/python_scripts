# parser to take c2x output and put it in the form required by Caesar
# note: the LATTICE_CART block must be in output.cell before the POSITIONS_FRAC block

import sys
import numpy as np

conversion_factor = 1822.888486 # conversion from atomic units to electron mass as a unit of mass - used for atomic masses

fileroot = sys.argv[1]

infile = open("output.cell", "r") # file generated by c2x
massfile = open("masses.dat", "r") # file that contains the atomic types and their masses in atomic units
outfile = open("structure.dat", "w") # file to be written to

comparefile = open("{}.cell".format(fileroot), "r") # original user input file - used to impose the same order on the atoms in structure.dat

class UnitError(Exception):
    """Exception raised when the input is not given in units of Bohr"""

    def __init__(self, expression, message):
        self.expression = expression
        self.message = message

class InputError(Exception):
    """Exception raised when there is something generally wrong with the input"""

    def __init__(self, expression, message):
        self.expression = expression
        self.message = message

# read order of atoms in fileroot.cell

atoms_order = [] # list to which the atoms will be added in the order in which they occur in fileroot.cell
atom_position_lines = {} # dictionary in which the output positions will be written by atom

for line in comparefile:

    if not line.split():
        continue # the line is empty

    if line.lower().startswith("%b") or line.lower().startswith("% b"):
        # the beginning of an input block

        if "positions_frac" in line.lower():

            for atom_position in comparefile:

                if atom_position.lower().startswith("%e") or atom_position.lower().startswith("% e"):
                    break # the end of the input block
                elif atom_position.split():
                    if atom_position.split()[0] not in atoms_order:
                        atoms_order.append(atom_position.split()[0])
                        atom_position_lines[atom_position.split()[0]] = []

        else:
            continue

        # all that is needed here is the order of the atoms, everything else is ignored

comparefile.close()

lattice_vectors = {}
atomic_masses = {}

# read atomic masses
for atom in massfile:
    atomic_masses[atom.split()[0]] = np.double(atom.split()[1])

for line in infile:

    if not line.split():
        continue # the line is empty

    if line.lower().startswith("%b") or line.lower().startswith("% b"):
        # the beginning of an input block

        if "lattice_cart" in line.lower():

            outfile.write("Lattice\n")

            if not "bohr" in infile.readline().lower():
                # since the default in CASTEP is Angstrom, we know that if this line doesn't say "Bohr", the measurements won't be in Bohr
                raise UnitError("Reading lattice vectors",
                "The lattice vectors are not given in units of Bohr, but this is required by Caesar.")

            for lattice_vector in infile:

                if lattice_vector.lower().startswith("%e") or lattice_vector.lower().startswith("% e"):
                    break # the end of the input block
                elif lattice_vector.split():
                    outfile.write("{}".format(lattice_vector))

                    lattice_vector_elements = lattice_vector.split()
                    dimensions = len(lattice_vector_elements)
                    lattice_array = np.zeros(dimensions, dtype=np.double)

                    for i in range(dimensions):
                        lattice_array[i] = np.double(lattice_vector_elements[i])

                    lattice_vectors["a_{}".format(len(lattice_vectors)+1)] = lattice_array

        elif "positions_frac" in line.lower():

            if not lattice_vectors: # lattice_vectors dictionary is empty - the LATTICE_CART block hasn't been read (yet)
                raise InputError("Reading atomic positions", "The LATTICE_CART block hasn't been read (yet), so I can't convert fractional to Cartesian coordinates.")

            outfile.write("Atoms\n")

            for atom_position in infile:

                if atom_position.lower().startswith("%e") or atom_position.lower().startswith("% e"):
                    break # the end of the input block
                elif atom_position.split():

                    atom_position_elements_cart = np.zeros(dimensions, dtype=np.double)
                    atom_position_elements_frac = atom_position.split()

                    atom_position_string = "  {}  {}".format(atom_position_elements_frac[0],
                    atomic_masses[atom_position_elements_frac[0]]*conversion_factor) # 0th element of the list designates the atom element

                    for i in range(dimensions):
                        atom_position_elements_cart += np.double(atom_position_elements_frac[i+1]) * lattice_vectors["a_{}".format(i+1)]

                    for atom_position_cart in atom_position_elements_cart:
                        atom_position_string += "  {}".format(atom_position_cart)

                    atom_position_lines[atom_position_elements_frac[0]].append(atom_position_string)

            # write the atomic positions to the structure.dat file
            for atom in atoms_order:
                for atom_position_line in atom_position_lines[atom]:
                    outfile.write("{}\n".format(atom_position_line))

        elif "symmetry" in line.lower():

            outfile.write("Symmetry\n")

            for symmetry_op in infile:

                if symmetry_op.lower().startswith("%e") or symmetry_op.lower().startswith("% e"):
                    break # the end of the input block
                elif symmetry_op.split():
                    outfile.write("{}".format(symmetry_op)) #the line is not empty

        else:

            for random_line in infile:
                if random_line.lower().startswith("%e") or random_line.lower().startswith("% e"):
                    break
                # structure.dat only needs the three cases treated explicitly above, everything else is ignored

outfile.write("End\n")

infile.close()
outfile.close()
