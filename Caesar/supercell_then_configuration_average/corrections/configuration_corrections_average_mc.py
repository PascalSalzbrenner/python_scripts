# script to average the wannier90 hopping parameters calculated for the different configurations of a supercell generated by the in-house
# Caesar code
# run in the directory containing the configurations directory and the supercell.dat file

# input files
# primitive_cell_correction_hr.dat files for each configuration generated by the supercell_hopping_average_mc.py script

# output
# configuration_correction_average_hr.dat: hopping parameter averaged over all configurations

# written by Pascal Salzbrenner, pts28

import sys
import numpy as np
from copy import deepcopy

# give as input arguments the indices of first and final point to be considered
first_point = int(sys.argv[1])
final_point = int(sys.argv[2])

# construct list to contain the lines which will be written to output
correction_lines = []

# first line is comment line
correction_lines.append("Caesar configuration average for hopping elements over {} configurations".format(final_point-first_point+1))

# iterate over all different points
for i in range(first_point, final_point+1):
    # define hopping dictionary for current configuration
    configuration_correction_dict = {}

    # open file containing hopping elements for current configuration
    correction_in = open("configurations/point.{}/wannier90_files/primitive_cell_correction_hr.dat".format(i), "r")

    # skip comment line
    correction_in.readline()

    # next line contains the number of wannier orbitals per unit cell, the one after that the number of hopping vectors
    num_wann = int(correction_in.readline())
    num_vec = int(correction_in.readline())

    # will be the same for all configurations - only carried out once
    if i == first_point:
        correction_lines.append(str(num_wann))
        correction_lines.append(str(num_vec))

        # based on the number of vectors, determine how many lines to read past, using the fact that the file has 15 points per line
        read_past = num_vec//15
        if num_vec%15 != 0:
            read_past+=1
            # one additional line with < 15 elements must be read past if there is a not fully filled line
        for j in range(read_past):
            correction_lines.append(correction_in.readline().rstrip("\n"))
    else:
        # lines must still be read past, but the preliminaries can be skipped, and they mustn't be written to the output
        for j in range(read_past):
            correction_in.readline()

    # read in the hopping vectors

    for line in correction_in:

        # read the hopping_vector, the from_orbital, the to_orbital, and the real and imaginary components of the strength
        hopping_data = line.split()
        hopping_vector = tuple(hopping_data[0:3])
        from_orbital = int(hopping_data[3])-1 # renumber to conform to internal Python representation
        to_orbital = int(hopping_data[4])-1
        strength = complex(float(hopping_data[5]), float(hopping_data[6]))

        if hopping_vector not in configuration_correction_dict:
            configuration_correction_dict[hopping_vector] = np.zeros((num_wann, num_wann), dtype=np.cdouble)

        configuration_correction_dict[hopping_vector][from_orbital][to_orbital] = strength

    correction_in.close()

    if i == first_point:
        # define dictionary to contain average correction, calculated as a rolling average
        # rolling average works as long as all primitive_cell_correction_hr.dat files contain exactly the same hopping vectors
        # this is the case for a set of points generated with Caesar
        correction_dict = deepcopy(configuration_correction_dict)
    else:
        # calculate rolling average - use point number to determine how many elements went into the current average
        for hop_vector in correction_dict.keys():
            correction_dict[hop_vector] = ((i-first_point)*correction_dict[hop_vector]+configuration_correction_dict[hop_vector])/(i-first_point+1)

# open output file
correction_average_hr = open("configuration_correction_average_hr.dat", "w")

# write out preample and empty correction_lines to then write the correction vector by vector
correction_average_hr.write("\n".join(correction_lines))
correction_average_hr.write("\n")
correction_lines  = []

for hop_vector, hop_matrix in correction_dict.items():
    for i in range(num_wann):
        for j in range(num_wann):
            correction_lines.append("   {}   {}   {}   {}   {}   {}   {}".format(hop_vector[0], hop_vector[1], hop_vector[2], j+1, i+1,
                                    hop_matrix[j][i].real, hop_matrix[j][i].imag))
    # add 1 to j and i to go from 0 to N-1 back to 1 to N

    # write after every hopping vector to avoid potential memory problems
    correction_average_hr.write("\n".join(correction_lines))
    correction_average_hr.write("\n")

    # clear correction_lines for new elements to be added to it
    correction_lines = []

correction_average_hr.close()
